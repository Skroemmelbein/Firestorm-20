import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  users: defineTable({
    email: v.string(),
    password_hash: v.optional(v.string()),
    first_name: v.optional(v.string()),
    last_name: v.optional(v.string()),
    full_name: v.optional(v.string()),
    role: v.union(v.literal("admin"), v.literal("manager"), v.literal("user"), v.literal("super_admin")),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("suspended"), v.literal("pending")),
    phone: v.optional(v.string()),
    avatar_url: v.optional(v.string()),
    timezone: v.optional(v.string()),
    language: v.optional(v.string()),
    preferences: v.optional(v.any()),
    permissions: v.optional(v.array(v.string())),
    last_login: v.optional(v.number()),
    login_count: v.optional(v.number()),
    failed_login_attempts: v.optional(v.number()),
    password_reset_token: v.optional(v.string()),
    password_reset_expires: v.optional(v.number()),
    email_verified: v.optional(v.boolean()),
    email_verification_token: v.optional(v.string()),
    two_factor_enabled: v.optional(v.boolean()),
    two_factor_secret: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_email", ["email"]).index("by_status", ["status"]).index("by_role", ["role"]).index("by_created_at", ["created_at"]).index("by_last_login", ["last_login"]),

  clients: defineTable({
    name: v.string(),
    email: v.optional(v.string()),
    phone: v.optional(v.string()),
    address: v.optional(v.string()),
    website: v.optional(v.string()),
    industry: v.optional(v.string()),
    company_size: v.optional(v.union(v.literal("1-10"), v.literal("11-50"), v.literal("51-200"), v.literal("201-500"), v.literal("500+"))),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("suspended"), v.literal("trial")),
    subscription_tier: v.union(v.literal("basic"), v.literal("premium"), v.literal("enterprise"), v.literal("custom")),
    billing_address: v.optional(v.string()),
    tax_id: v.optional(v.string()),
    contract_start: v.optional(v.number()),
    contract_end: v.optional(v.number()),
    monthly_spend_limit: v.optional(v.number()),
    total_revenue: v.optional(v.number()),
    logo_url: v.optional(v.string()),
    notes: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    created_by: v.id("users"),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_status", ["status"]).index("by_created_by", ["created_by"]).index("by_subscription_tier", ["subscription_tier"]).index("by_name", ["name"]).index("by_contract_end", ["contract_end"]),

  members: defineTable({
    user_id: v.optional(v.id("users")),
    client_id: v.optional(v.id("clients")),
    member_id: v.string(),
    first_name: v.optional(v.string()),
    last_name: v.optional(v.string()),
    full_name: v.optional(v.string()),
    email: v.optional(v.string()),
    phone: v.optional(v.string()),
    date_of_birth: v.optional(v.number()),
    gender: v.optional(v.union(v.literal("male"), v.literal("female"), v.literal("other"), v.literal("prefer_not_to_say"))),
    tier: v.union(v.literal("basic"), v.literal("premium"), v.literal("elite"), v.literal("executive")),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("pending"), v.literal("suspended"), v.literal("churned")),
    engagement_score: v.optional(v.number()),
    total_spend: v.optional(v.number()),
    lifetime_value: v.optional(v.number()),
    acquisition_channel: v.optional(v.string()),
    acquisition_cost: v.optional(v.number()),
    last_active: v.optional(v.number()),
    location: v.optional(v.string()),
    timezone: v.optional(v.string()),
    language: v.optional(v.string()),
    preferences: v.optional(v.any()),
    tags: v.optional(v.array(v.string())),
    notes: v.optional(v.string()),
    social_profiles: v.optional(v.any()),
    communication_preferences: v.optional(v.any()),
    permissions: v.optional(v.any()),
    referral_code: v.optional(v.string()),
    referred_by: v.optional(v.id("members")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_user", ["user_id"]).index("by_client", ["client_id"]).index("by_member_id", ["member_id"]).index("by_email", ["email"]).index("by_tier", ["tier"]).index("by_status", ["status"]).index("by_engagement_score", ["engagement_score"]).index("by_last_active", ["last_active"]),

  communications: defineTable({
    channel: v.union(v.literal("sms"), v.literal("mms"), v.literal("email"), v.literal("voice"), v.literal("chat"), v.literal("conversation"), v.literal("push"), v.literal("webhook")),
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    to_number: v.optional(v.string()),
    from_number: v.optional(v.string()),
    to_email: v.optional(v.string()),
    from_email: v.optional(v.string()),
    content: v.string(),
    subject: v.optional(v.string()),
    message_type: v.optional(v.union(v.literal("transactional"), v.literal("marketing"), v.literal("notification"), v.literal("support"))),
    template_id: v.optional(v.string()),
    campaign_id: v.optional(v.id("campaigns")),
    status: v.union(v.literal("queued"), v.literal("sent"), v.literal("delivered"), v.literal("failed"), v.literal("bounced"), v.literal("read"), v.literal("clicked"), v.literal("replied")),
    provider: v.union(v.literal("twilio"), v.literal("sendgrid"), v.literal("other")),
    provider_id: v.optional(v.string()),
    provider_status: v.optional(v.string()),
    provider_response: v.optional(v.any()),
    cost: v.optional(v.number()),
    segments: v.optional(v.number()),
    media_urls: v.optional(v.array(v.string())),
    attachments: v.optional(v.array(v.any())),
    error_message: v.optional(v.string()),
    error_code: v.optional(v.string()),
    retry_count: v.optional(v.number()),
    metadata: v.optional(v.any()),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    member_id: v.optional(v.id("members")),
    sent_at: v.optional(v.number()),
    delivered_at: v.optional(v.number()),
    read_at: v.optional(v.number()),
    clicked_at: v.optional(v.number()),
    replied_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_user", ["user_id"]).index("by_member", ["member_id"]).index("by_channel", ["channel"]).index("by_status", ["status"]).index("by_campaign", ["campaign_id"]).index("by_provider", ["provider"]).index("by_sent_at", ["sent_at"]),

  subscriptions: defineTable({
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    member_id: v.optional(v.id("members")),
    subscription_name: v.optional(v.string()),
    plan_name: v.string(),
    plan_type: v.union(v.literal("monthly"), v.literal("yearly"), v.literal("one-time"), v.literal("usage-based")),
    billing_cycle: v.optional(v.union(v.literal("monthly"), v.literal("quarterly"), v.literal("yearly"))),
    amount: v.number(),
    setup_fee: v.optional(v.number()),
    discount_amount: v.optional(v.number()),
    discount_percentage: v.optional(v.number()),
    tax_rate: v.optional(v.number()),
    currency: v.string(),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("cancelled"), v.literal("past_due"), v.literal("paused"), v.literal("trial")),
    payment_method: v.optional(v.string()),
    nmi_customer_id: v.optional(v.string()),
    nmi_subscription_id: v.optional(v.string()),
    nmi_plan_id: v.optional(v.string()),
    trial_start_date: v.optional(v.number()),
    trial_end_date: v.optional(v.number()),
    current_period_start: v.optional(v.number()),
    current_period_end: v.optional(v.number()),
    next_billing_date: v.optional(v.number()),
    last_billing_date: v.optional(v.number()),
    cancellation_date: v.optional(v.number()),
    cancellation_reason: v.optional(v.string()),
    auto_renew: v.optional(v.boolean()),
    proration_behavior: v.optional(v.string()),
    metadata: v.optional(v.any()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_user", ["user_id"]).index("by_member", ["member_id"]).index("by_status", ["status"]).index("by_nmi_customer", ["nmi_customer_id"]).index("by_next_billing_date", ["next_billing_date"]).index("by_plan_type", ["plan_type"]),

  transactions: defineTable({
    subscription_id: v.optional(v.id("subscriptions")),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    member_id: v.optional(v.id("members")),
    transaction_id: v.string(),
    nmi_transaction_id: v.optional(v.string()),
    invoice_id: v.optional(v.string()),
    amount: v.number(),
    tax_amount: v.optional(v.number()),
    fee_amount: v.optional(v.number()),
    net_amount: v.optional(v.number()),
    currency: v.string(),
    exchange_rate: v.optional(v.number()),
    type: v.union(v.literal("charge"), v.literal("refund"), v.literal("chargeback"), v.literal("adjustment"), v.literal("credit")),
    status: v.union(v.literal("pending"), v.literal("completed"), v.literal("failed"), v.literal("cancelled"), v.literal("disputed"), v.literal("refunded")),
    payment_method: v.optional(v.string()),
    payment_method_details: v.optional(v.any()),
    gateway_response: v.optional(v.any()),
    authorization_code: v.optional(v.string()),
    reference_number: v.optional(v.string()),
    description: v.optional(v.string()),
    failure_reason: v.optional(v.string()),
    failure_code: v.optional(v.string()),
    risk_score: v.optional(v.number()),
    fraud_details: v.optional(v.any()),
    billing_address: v.optional(v.any()),
    shipping_address: v.optional(v.any()),
    customer_ip: v.optional(v.string()),
    user_agent: v.optional(v.string()),
    metadata: v.optional(v.any()),
    processed_at: v.optional(v.number()),
    settled_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_subscription", ["subscription_id"]).index("by_client", ["client_id"]).index("by_transaction_id", ["transaction_id"]).index("by_status", ["status"]).index("by_type", ["type"]).index("by_processed_at", ["processed_at"]).index("by_amount", ["amount"]),

  campaigns: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    type: v.union(v.literal("sms"), v.literal("email"), v.literal("mixed"), v.literal("voice"), v.literal("push")),
    category: v.optional(v.union(v.literal("marketing"), v.literal("transactional"), v.literal("notification"), v.literal("retention"))),
    status: v.union(v.literal("draft"), v.literal("active"), v.literal("paused"), v.literal("completed"), v.literal("archived")),
    priority: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high"), v.literal("urgent"))),
    target_audience: v.optional(v.any()),
    audience_size: v.optional(v.number()),
    message_template: v.optional(v.string()),
    subject_template: v.optional(v.string()),
    personalization_fields: v.optional(v.array(v.string())),
    schedule_type: v.union(v.literal("immediate"), v.literal("scheduled"), v.literal("recurring"), v.literal("triggered")),
    scheduled_at: v.optional(v.number()),
    recurring_pattern: v.optional(v.string()),
    trigger_conditions: v.optional(v.any()),
    budget: v.optional(v.number()),
    cost_per_message: v.optional(v.number()),
    expected_revenue: v.optional(v.number()),
    conversion_goal: v.optional(v.string()),
    a_b_test_config: v.optional(v.any()),
    tags: v.optional(v.array(v.string())),
    created_by: v.id("users"),
    client_id: v.optional(v.id("clients")),
    launched_at: v.optional(v.number()),
    completed_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_status", ["status"]).index("by_created_by", ["created_by"]).index("by_client", ["client_id"]).index("by_type", ["type"]).index("by_scheduled_at", ["scheduled_at"]).index("by_priority", ["priority"]),

  benefits: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    type: v.union(v.literal("discount"), v.literal("reward"), v.literal("access"), v.literal("service"), v.literal("cashback"), v.literal("points")),
    category: v.optional(v.string()),
    value: v.optional(v.string()),
    value_type: v.optional(v.union(v.literal("percentage"), v.literal("fixed"), v.literal("points"), v.literal("access"))),
    minimum_spend: v.optional(v.number()),
    maximum_usage: v.optional(v.number()),
    usage_period: v.optional(v.union(v.literal("daily"), v.literal("weekly"), v.literal("monthly"), v.literal("yearly"), v.literal("lifetime"))),
    tier_requirement: v.optional(v.union(v.literal("basic"), v.literal("premium"), v.literal("elite"), v.literal("executive"))),
    eligibility_criteria: v.optional(v.any()),
    terms_conditions: v.optional(v.string()),
    start_date: v.optional(v.number()),
    end_date: v.optional(v.number()),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("expired"), v.literal("draft")),
    priority: v.optional(v.number()),
    auto_apply: v.optional(v.boolean()),
    stackable: v.optional(v.boolean()),
    client_id: v.optional(v.id("clients")),
    created_by: v.optional(v.id("users")),
    usage_count: v.optional(v.number()),
    redemption_count: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_type", ["type"]).index("by_status", ["status"]).index("by_client", ["client_id"]).index("by_tier_requirement", ["tier_requirement"]).index("by_start_date", ["start_date"]).index("by_end_date", ["end_date"]),

  member_benefits: defineTable({
    member_id: v.id("members"),
    benefit_id: v.id("benefits"),
    status: v.union(v.literal("active"), v.literal("used"), v.literal("expired"), v.literal("revoked")),
    usage_count: v.optional(v.number()),
    remaining_usage: v.optional(v.number()),
    value_redeemed: v.optional(v.number()),
    granted_at: v.number(),
    expires_at: v.optional(v.number()),
    used_at: v.optional(v.number()),
    revoked_at: v.optional(v.number()),
    revocation_reason: v.optional(v.string()),
    granted_by: v.optional(v.id("users")),
    transaction_id: v.optional(v.id("transactions")),
    notes: v.optional(v.string()),
    metadata: v.optional(v.any()),
  }).index("by_member", ["member_id"]).index("by_benefit", ["benefit_id"]).index("by_status", ["status"]).index("by_granted_at", ["granted_at"]).index("by_expires_at", ["expires_at"]),

  analytics: defineTable({
    metric_name: v.string(),
    metric_value: v.number(),
    metric_type: v.union(v.literal("counter"), v.literal("gauge"), v.literal("histogram"), v.literal("timer")),
    metric_unit: v.optional(v.string()),
    dimensions: v.optional(v.any()),
    tags: v.optional(v.array(v.string())),
    source: v.optional(v.string()),
    environment: v.optional(v.union(v.literal("production"), v.literal("staging"), v.literal("development"))),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    session_id: v.optional(v.string()),
    request_id: v.optional(v.string()),
    correlation_id: v.optional(v.string()),
    metadata: v.optional(v.any()),
    recorded_at: v.number(),
  }).index("by_metric_name", ["metric_name"]).index("by_client", ["client_id"]).index("by_recorded_at", ["recorded_at"]).index("by_metric_type", ["metric_type"]).index("by_source", ["source"]),

  settings: defineTable({
    key: v.string(),
    value: v.any(),
    type: v.union(v.literal("system"), v.literal("client"), v.literal("user"), v.literal("global")),
    data_type: v.optional(v.union(v.literal("string"), v.literal("number"), v.literal("boolean"), v.literal("object"), v.literal("array"))),
    category: v.optional(v.string()),
    description: v.optional(v.string()),
    default_value: v.optional(v.any()),
    validation_rules: v.optional(v.any()),
    is_encrypted: v.optional(v.boolean()),
    is_public: v.optional(v.boolean()),
    requires_restart: v.optional(v.boolean()),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    environment: v.optional(v.union(v.literal("production"), v.literal("staging"), v.literal("development"))),
    version: v.optional(v.string()),
    last_modified_by: v.optional(v.id("users")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_key", ["key"]).index("by_type", ["type"]).index("by_client", ["client_id"]).index("by_user", ["user_id"]).index("by_category", ["category"]),

  webhooks: defineTable({
    provider: v.string(),
    event_type: v.string(),
    event_id: v.optional(v.string()),
    webhook_id: v.optional(v.string()),
    payload: v.any(),
    headers: v.optional(v.any()),
    signature: v.optional(v.string()),
    signature_verified: v.optional(v.boolean()),
    status: v.union(v.literal("received"), v.literal("processed"), v.literal("failed"), v.literal("ignored"), v.literal("retrying")),
    processing_attempts: v.optional(v.number()),
    max_attempts: v.optional(v.number()),
    next_retry_at: v.optional(v.number()),
    error_message: v.optional(v.string()),
    error_code: v.optional(v.string()),
    processing_time: v.optional(v.number()),
    response_data: v.optional(v.any()),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    related_entity_type: v.optional(v.string()),
    related_entity_id: v.optional(v.string()),
    source_ip: v.optional(v.string()),
    user_agent: v.optional(v.string()),
    processed_at: v.optional(v.number()),
    created_at: v.number(),
  }).index("by_provider", ["provider"]).index("by_event_type", ["event_type"]).index("by_status", ["status"]).index("by_created_at", ["created_at"]).index("by_processed_at", ["processed_at"]).index("by_client", ["client_id"]),

  conversations: defineTable({
    conversation_sid: v.string(),
    friendly_name: v.optional(v.string()),
    unique_name: v.optional(v.string()),
    chat_service_sid: v.optional(v.string()),
    messaging_service_sid: v.optional(v.string()),
    status: v.union(v.literal("active"), v.literal("inactive"), v.literal("closed"), v.literal("archived")),
    state: v.optional(v.union(v.literal("active"), v.literal("inactive"), v.literal("closed"))),
    participant_count: v.optional(v.number()),
    message_count: v.optional(v.number()),
    media_count: v.optional(v.number()),
    attributes: v.optional(v.any()),
    timers: v.optional(v.any()),
    client_id: v.optional(v.id("clients")),
    member_id: v.optional(v.id("members")),
    user_id: v.optional(v.id("users")),
    campaign_id: v.optional(v.id("campaigns")),
    tags: v.optional(v.array(v.string())),
    priority: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high"), v.literal("urgent"))),
    last_message_at: v.optional(v.number()),
    last_read_message_index: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_conversation_sid", ["conversation_sid"]).index("by_client", ["client_id"]).index("by_member", ["member_id"]).index("by_status", ["status"]).index("by_last_message_at", ["last_message_at"]).index("by_campaign", ["campaign_id"]),

  scheduled_jobs: defineTable({
    campaign_id: v.id("campaigns"),
    job_type: v.union(v.literal("send_message"), v.literal("delay"), v.literal("trigger_event"), v.literal("condition_check"), v.literal("webhook_call")),
    job_name: v.optional(v.string()),
    scheduled_at: v.number(),
    status: v.union(v.literal("pending"), v.literal("running"), v.literal("completed"), v.literal("failed"), v.literal("cancelled"), v.literal("skipped")),
    priority: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high"), v.literal("urgent"))),
    retry_count: v.optional(v.number()),
    max_retries: v.optional(v.number()),
    retry_delay: v.optional(v.number()),
    timeout: v.optional(v.number()),
    payload: v.optional(v.any()),
    result: v.optional(v.any()),
    error_message: v.optional(v.string()),
    error_code: v.optional(v.string()),
    execution_time: v.optional(v.number()),
    dependencies: v.optional(v.array(v.id("scheduled_jobs"))),
    tags: v.optional(v.array(v.string())),
    executed_at: v.optional(v.number()),
    completed_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_campaign", ["campaign_id"]).index("by_scheduled_at", ["scheduled_at"]).index("by_status", ["status"]).index("by_job_type", ["job_type"]).index("by_priority", ["priority"]),

  campaign_executions: defineTable({
    campaign_id: v.id("campaigns"),
    execution_type: v.union(v.literal("immediate"), v.literal("scheduled"), v.literal("recurring")),
    target_count: v.optional(v.number()),
    sent_count: v.optional(v.number()),
    failed_count: v.optional(v.number()),
    status: v.union(v.literal("queued"), v.literal("running"), v.literal("completed"), v.literal("failed"), v.literal("paused")),
    started_at: v.optional(v.number()),
    completed_at: v.optional(v.number()),
    error_message: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_campaign", ["campaign_id"]).index("by_status", ["status"]),

  // Security / RBAC
  roles: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_name", ["name"]),

  permissions: defineTable({
    key: v.string(),
    description: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_key", ["key"]),

  role_assignments: defineTable({
    user_id: v.id("users"),
    role_id: v.id("roles"),
    scope_type: v.optional(v.string()), // e.g., "client"
    scope_id: v.optional(v.string()),
    created_at: v.number(),
  }).index("by_user", ["user_id"]).index("by_role", ["role_id"]),

  api_keys: defineTable({
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    name: v.string(),
    key_hash: v.string(),
    scopes: v.optional(v.array(v.string())),
    last_used_at: v.optional(v.number()),
    expires_at: v.optional(v.number()),
    created_at: v.number(),
    revoked_at: v.optional(v.number()),
  }).index("by_client", ["client_id"]).index("by_user", ["user_id"]).index("by_name", ["name"]),

  oauth_connections: defineTable({
    user_id: v.id("users"),
    provider: v.string(),
    provider_user_id: v.string(),
    access_token_preview: v.optional(v.string()),
    refresh_token_preview: v.optional(v.string()),
    expires_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_user", ["user_id"]).index("by_provider", ["provider", "provider_user_id"]),

  audit_logs: defineTable({
    actor_user_id: v.optional(v.id("users")),
    actor_client_id: v.optional(v.id("clients")),
    action: v.string(),
    entity_type: v.string(),
    entity_id: v.string(),
    changes: v.optional(v.any()),
    request_id: v.optional(v.string()),
    ip: v.optional(v.string()),
    user_agent: v.optional(v.string()),
    metadata: v.optional(v.any()),
    created_at: v.number(),
  }).index("by_entity", ["entity_type", "entity_id"]).index("by_actor", ["actor_user_id"]).index("by_action", ["action"]).index("by_created_at", ["created_at"]),

  idempotency_keys: defineTable({
    request_key: v.string(),
    status: v.union(v.literal("processing"), v.literal("succeeded"), v.literal("failed")),
    response: v.optional(v.any()),
    error: v.optional(v.string()),
    expires_at: v.number(),
    created_at: v.number(),
  }).index("by_request_key", ["request_key"]).index("by_expires_at", ["expires_at"]),

  // Compliance / Governance
  consent_records: defineTable({
    member_id: v.optional(v.id("members")),
    user_id: v.optional(v.id("users")),
    client_id: v.optional(v.id("clients")),
    channel: v.optional(v.union(v.literal("sms"), v.literal("email"), v.literal("voice"), v.literal("push"))),
    purpose: v.string(),
    scope: v.optional(v.string()),
    status: v.union(v.literal("granted"), v.literal("revoked"), v.literal("pending")),
    version: v.optional(v.string()),
    evidence: v.optional(v.any()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_member", ["member_id"]).index("by_client", ["client_id"]).index("by_purpose", ["purpose"]).index("by_status", ["status"]),

  data_access_logs: defineTable({
    actor_user_id: v.optional(v.id("users")),
    entity_type: v.string(),
    entity_id: v.string(),
    reason: v.optional(v.string()),
    created_at: v.number(),
  }).index("by_entity", ["entity_type", "entity_id"]).index("by_actor", ["actor_user_id"]).index("by_created_at", ["created_at"]),

  data_retention_policies: defineTable({
    table: v.string(),
    field: v.optional(v.string()),
    policy: v.string(), // e.g., "delete-after"
    ttl_days: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_table", ["table"]),

  erasure_requests: defineTable({
    subject_type: v.union(v.literal("member"), v.literal("user")),
    subject_id: v.string(),
    scope: v.optional(v.any()),
    status: v.union(v.literal("requested"), v.literal("in_progress"), v.literal("completed"), v.literal("rejected")),
    requested_at: v.number(),
    completed_at: v.optional(v.number()),
    notes: v.optional(v.string()),
  }).index("by_subject", ["subject_type", "subject_id"]).index("by_status", ["status"]),

  // Billing / Finance
  invoices: defineTable({
    client_id: v.optional(v.id("clients")),
    member_id: v.optional(v.id("members")),
    subscription_id: v.optional(v.id("subscriptions")),
    invoice_number: v.string(),
    currency: v.string(),
    subtotal: v.number(),
    tax_total: v.optional(v.number()),
    total: v.number(),
    balance_due: v.number(),
    status: v.union(v.literal("draft"), v.literal("open"), v.literal("paid"), v.literal("void"), v.literal("uncollectible")),
    due_at: v.optional(v.number()),
    issued_at: v.optional(v.number()),
    paid_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_subscription", ["subscription_id"]).index("by_invoice_number", ["invoice_number"]).index("by_status", ["status"]),

  invoice_lines: defineTable({
    invoice_id: v.id("invoices"),
    description: v.optional(v.string()),
    quantity: v.number(),
    unit_price: v.number(),
    amount: v.number(),
    subscription_id: v.optional(v.id("subscriptions")),
    proration: v.optional(v.boolean()),
    created_at: v.number(),
  }).index("by_invoice", ["invoice_id"]),

  refunds: defineTable({
    transaction_id: v.optional(v.id("transactions")),
    invoice_id: v.optional(v.id("invoices")),
    amount: v.number(),
    reason: v.optional(v.string()),
    status: v.union(v.literal("pending"), v.literal("succeeded"), v.literal("failed")),
    created_at: v.number(),
    processed_at: v.optional(v.number()),
  }).index("by_transaction", ["transaction_id"]).index("by_invoice", ["invoice_id"]).index("by_status", ["status"]),

  disputes: defineTable({
    transaction_id: v.optional(v.id("transactions")),
    amount: v.number(),
    currency: v.string(),
    reason: v.optional(v.string()),
    status: v.union(v.literal("needs_response"), v.literal("under_review"), v.literal("won"), v.literal("lost")),
    evidence: v.optional(v.any()),
    created_at: v.number(),
    resolved_at: v.optional(v.number()),
  }).index("by_transaction", ["transaction_id"]).index("by_status", ["status"]),

  ledger_entries: defineTable({
    client_id: v.optional(v.id("clients")),
    account: v.string(), // e.g., AR, Revenue, Tax
    debit: v.optional(v.number()),
    credit: v.optional(v.number()),
    currency: v.string(),
    description: v.optional(v.string()),
    reference_type: v.optional(v.string()),
    reference_id: v.optional(v.string()),
    created_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_account", ["account"]).index("by_reference", ["reference_type", "reference_id"]),

  pricing_plans: defineTable({
    name: v.string(),
    currency: v.string(),
    interval: v.union(v.literal("monthly"), v.literal("yearly"), v.literal("one-time")),
    unit_amount: v.number(),
    features: v.optional(v.any()),
    metadata: v.optional(v.any()),
    active: v.boolean(),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_name", ["name"]).index("by_active", ["active"]),

  usage_records: defineTable({
    client_id: v.optional(v.id("clients")),
    member_id: v.optional(v.id("members")),
    subscription_id: v.optional(v.id("subscriptions")),
    metric: v.string(),
    quantity: v.number(),
    recorded_at: v.number(),
    metadata: v.optional(v.any()),
  }).index("by_subscription", ["subscription_id"]).index("by_metric", ["metric"]).index("by_recorded_at", ["recorded_at"]),

  credits: defineTable({
    client_id: v.optional(v.id("clients")),
    member_id: v.optional(v.id("members")),
    amount: v.number(),
    currency: v.string(),
    reason: v.optional(v.string()),
    expires_at: v.optional(v.number()),
    created_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_member", ["member_id"]).index("by_expires_at", ["expires_at"]),

  promotions: defineTable({
    code: v.string(),
    description: v.optional(v.string()),
    percentage_off: v.optional(v.number()),
    amount_off: v.optional(v.number()),
    currency: v.optional(v.string()),
    max_redemptions: v.optional(v.number()),
    times_redeemed: v.optional(v.number()),
    starts_at: v.optional(v.number()),
    ends_at: v.optional(v.number()),
    active: v.boolean(),
    created_at: v.number(),
  }).index("by_code", ["code"]).index("by_active", ["active"]).index("by_ends_at", ["ends_at"]),

  payouts: defineTable({
    client_id: v.optional(v.id("clients")),
    amount: v.number(),
    currency: v.string(),
    status: v.union(v.literal("pending"), v.literal("paid"), v.literal("failed")),
    scheduled_at: v.optional(v.number()),
    paid_at: v.optional(v.number()),
    created_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_status", ["status"]),

  balances: defineTable({
    client_id: v.id("clients"),
    current: v.number(),
    pending: v.optional(v.number()),
    currency: v.string(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]),

  payment_methods: defineTable({
    owner_type: v.union(v.literal("member"), v.literal("client")),
    owner_id: v.string(),
    provider: v.optional(v.string()),
    last4: v.optional(v.string()),
    brand: v.optional(v.string()),
    exp_month: v.optional(v.number()),
    exp_year: v.optional(v.number()),
    token_ref: v.optional(v.string()),
    default: v.optional(v.boolean()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_owner", ["owner_type", "owner_id"]).index("by_default", ["default"]),

  billing_profiles: defineTable({
    client_id: v.optional(v.id("clients")),
    member_id: v.optional(v.id("members")),
    address: v.optional(v.any()),
    tax_id: v.optional(v.string()),
    email: v.optional(v.string()),
    phone: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_member", ["member_id"]),

  // Marketing / Automation
  message_templates: defineTable({
    name: v.string(),
    channel: v.union(v.literal("sms"), v.literal("email"), v.literal("voice"), v.literal("push")),
    version: v.string(),
    subject: v.optional(v.string()),
    content: v.string(),
    variables: v.optional(v.array(v.string())),
    metadata: v.optional(v.any()),
    created_by: v.optional(v.id("users")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_name", ["name"]).index("by_channel", ["channel"]).index("by_version", ["version"]),

  audiences: defineTable({
    name: v.string(),
    definition: v.any(), // rule definition
    description: v.optional(v.string()),
    client_id: v.optional(v.id("clients")),
    created_by: v.optional(v.id("users")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_name", ["name"]),

  audience_memberships: defineTable({
    audience_id: v.id("audiences"),
    member_id: v.id("members"),
    added_at: v.number(),
    expires_at: v.optional(v.number()),
    metadata: v.optional(v.any()),
  }).index("by_audience", ["audience_id"]).index("by_member", ["member_id"]).index("by_expires_at", ["expires_at"]),

  journey_definitions: defineTable({
    name: v.string(),
    description: v.optional(v.string()),
    definition: v.any(),
    status: v.union(v.literal("draft"), v.literal("active"), v.literal("archived")),
    client_id: v.optional(v.id("clients")),
    created_by: v.optional(v.id("users")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_status", ["status"]).index("by_name", ["name"]),

  journey_runs: defineTable({
    journey_id: v.id("journey_definitions"),
    member_id: v.id("members"),
    state: v.string(),
    last_step: v.optional(v.string()),
    last_transition_at: v.optional(v.number()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_journey", ["journey_id"]).index("by_member", ["member_id"]).index("by_updated_at", ["updated_at"]),

  experiments: defineTable({
    name: v.string(),
    hypothesis: v.optional(v.string()),
    variants: v.array(v.string()),
    status: v.union(v.literal("draft"), v.literal("running"), v.literal("completed")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_status", ["status"]).index("by_name", ["name"]),

  attribution_events: defineTable({
    member_id: v.optional(v.id("members")),
    campaign_id: v.optional(v.id("campaigns")),
    source: v.string(),
    medium: v.optional(v.string()),
    channel: v.optional(v.string()),
    event: v.string(),
    value: v.optional(v.number()),
    occurred_at: v.number(),
    metadata: v.optional(v.any()),
  }).index("by_member", ["member_id"]).index("by_campaign", ["campaign_id"]).index("by_source", ["source"]).index("by_occurred_at", ["occurred_at"]),

  event_stream: defineTable({
    type: v.string(),
    data: v.any(),
    member_id: v.optional(v.id("members")),
    user_id: v.optional(v.id("users")),
    client_id: v.optional(v.id("clients")),
    request_id: v.optional(v.string()),
    recorded_at: v.number(),
  }).index("by_type", ["type"]).index("by_member", ["member_id"]).index("by_recorded_at", ["recorded_at"]),

  // Ops / Observability
  job_runs: defineTable({
    job_name: v.string(),
    job_id: v.optional(v.string()),
    status: v.union(v.literal("queued"), v.literal("running"), v.literal("succeeded"), v.literal("failed"), v.literal("cancelled")),
    started_at: v.optional(v.number()),
    finished_at: v.optional(v.number()),
    duration_ms: v.optional(v.number()),
    result: v.optional(v.any()),
    error_message: v.optional(v.string()),
    attempt: v.optional(v.number()),
    created_at: v.number(),
  }).index("by_status", ["status"]).index("by_job_name", ["job_name"]).index("by_started_at", ["started_at"]),

  dead_letters: defineTable({
    queue: v.string(),
    payload: v.any(),
    error_message: v.optional(v.string()),
    failed_at: v.number(),
    retry_after: v.optional(v.number()),
  }).index("by_queue", ["queue"]).index("by_failed_at", ["failed_at"]),

  rate_limits: defineTable({
    subject_type: v.string(), // user, client, api_key
    subject_id: v.string(),
    key: v.string(),
    limit: v.number(),
    window_seconds: v.number(),
    used: v.number(),
    reset_at: v.number(),
  }).index("by_subject", ["subject_type", "subject_id"]).index("by_key", ["key"]).index("by_reset_at", ["reset_at"]),

  alerts: defineTable({
    name: v.string(),
    severity: v.union(v.literal("info"), v.literal("warning"), v.literal("critical")),
    rule: v.any(),
    status: v.union(v.literal("open"), v.literal("acknowledged"), v.literal("resolved")),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_status", ["status"]).index("by_severity", ["severity"]),

  // Tenant / Features
  tenant_settings: defineTable({
    client_id: v.id("clients"),
    key: v.string(),
    value: v.any(),
    updated_at: v.number(),
    created_at: v.number(),
  }).index("by_client", ["client_id"]).index("by_key", ["key"]),

  feature_flags: defineTable({
    key: v.string(),
    description: v.optional(v.string()),
    enabled: v.boolean(),
    rules: v.optional(v.any()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_key", ["key"]).index("by_enabled", ["enabled"]),

  // AI Voice Calls & Member Interactions
  ai_voice_calls: defineTable({
    call_id: v.string(), // provider call SID/ID
    member_id: v.optional(v.id("members")),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")), // internal agent if any
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    status: v.union(
      v.literal("queued"),
      v.literal("ringing"),
      v.literal("in_progress"),
      v.literal("completed"),
      v.literal("failed"),
      v.literal("busy"),
      v.literal("no_answer")
    ),
    started_at: v.optional(v.number()),
    ended_at: v.optional(v.number()),
    duration_ms: v.optional(v.number()),
    language: v.optional(v.string()),
    sentiment: v.optional(v.string()),
    intents: v.optional(v.array(v.string())),
    entities: v.optional(v.any()),
    transcript: v.optional(v.string()),
    transcript_status: v.optional(v.union(v.literal("pending"), v.literal("completed"), v.literal("failed"))),
    recording_url: v.optional(v.string()),
    audio_url: v.optional(v.string()),
    segments: v.optional(v.array(v.any())), // [{speaker, start, end, text}]
    metadata: v.optional(v.any()),
    provider: v.optional(v.string()),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_call_id", ["call_id"]).index("by_member", ["member_id"]).index("by_client", ["client_id"]).index("by_status", ["status"]).index("by_started_at", ["started_at"]),

  member_interactions: defineTable({
    member_id: v.id("members"),
    client_id: v.optional(v.id("clients")),
    user_id: v.optional(v.id("users")),
    channel: v.union(v.literal("sms"), v.literal("mms"), v.literal("email"), v.literal("voice"), v.literal("chat")),
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    content: v.optional(v.string()),
    content_summary: v.optional(v.string()),
    related_communication_id: v.optional(v.id("communications")),
    related_call_id: v.optional(v.id("ai_voice_calls")),
    status: v.optional(v.union(v.literal("received"), v.literal("sent"), v.literal("handled"), v.literal("escalated"))),
    intent: v.optional(v.string()),
    sentiment: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    metadata: v.optional(v.any()),
    occurred_at: v.number(),
    created_at: v.number(),
    updated_at: v.number(),
  }).index("by_member", ["member_id"]).index("by_channel", ["channel"]).index("by_direction", ["direction"]).index("by_occurred_at", ["occurred_at"]).index("by_related_comm", ["related_communication_id"]).index("by_related_call", ["related_call_id"]),
});
